<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>God's Coin Toss</title>
    <!-- Include the Matter.js physics engine from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #1a1a1a;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        .question {
            font-size: 1.2em;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            background-color: #eef7ff;
            border-left: 5px solid #007bff;
            border-radius: 4px;
        }
        .buttons {
            text-align: center;
            margin: 30px 0;
        }
        .main-button {
            font-size: 1.2em;
            padding: 15px 30px;
            margin: 0 10px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.3s;
        }
        .main-button:hover {
            background-color: #0056b3;
        }
        #explanationContainer {
            display: none;
            margin-top: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fafafa;
        }
        .simulation-container {
            margin-top: 20px;
            padding: 15px;
            border: 1px dashed #ccc;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        canvas {
            background-color: #fff;
            border: 1px solid #ddd;
            display: block;
            margin: 10px auto;
            max-width: 100%;
            height: auto;
        }
        .sim-controls {
            text-align: center;
            margin-top: 15px;
        }
        .sim-controls button {
            padding: 8px 16px;
            margin: 0 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            cursor: pointer;
        }
        #toggleBtn.on, #toggleTeleportBtn.on {
            background-color: #dc3545;
            color: white;
            border-color: #dc3545;
        }
        #toggleBtn.off, #toggleTeleportBtn.off {
             background-color: #28a745;
             color: white;
             border-color: #28a745;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        .stat-item {
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
            text-align: center;
        }
        .stat-item strong {
            display: block;
            font-size: 1.2em;
        }
        .stat-label {
            font-size: 0.9em;
            color: #555;
        }
        code {
            background-color: #eee;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: "Courier New", Courier, monospace;
        }

        /* Styles for the 1/2 Simulation */
        #teleporter-viz {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
            padding: 20px;
            background: #f0f0f0;
            border-radius: 5px;
            min-height: 150px;
        }
        .location-container {
            text-align: center;
        }
        .location {
            width: 100px;
            height: 100px;
            background-color: #ccc;
            border: 2px solid #aaa;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.5s;
        }
        .person {
            width: 40px;
            height: 40px;
            background-color: #333;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .location-label {
            margin-bottom: 10px;
            font-weight: bold;
        }

        /* --- MOBILE FRIENDLY STYLES --- */
        @media (max-width: 600px) {
            body {
                margin: 10px;
                padding: 0;
            }
            .container {
                padding: 15px;
                margin: 0;
                box-shadow: none;
            }
            .buttons {
                /* Stack buttons vertically */
                display: flex;
                flex-direction: column;
                gap: 15px;
            }
            .main-button {
                margin: 0;
            }
            .stats {
                /* Change from 2 columns to 1 column */
                grid-template-columns: 1fr;
            }
            #teleporter-viz {
                /* Stack locations vertically instead of side-by-side */
                flex-direction: column;
                gap: 20px;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>God's Coin Toss: A Test of Your Metaphysics</h1>
        <p>This puzzle, described in Scott Aaronson's <em>Quantum Computing since Democritus</em>, explores how we reason about our own existence. Here is the scenario:</p>
        
        <ul>
            <li>At the beginning of time, God flips a fair coin.</li>
            <li>If the coin is <strong>Tails</strong>, God creates one room containing one person with <strong>red hair</strong>.</li>
            <li>If the coin is <strong>Heads</strong>, God creates two rooms: one with a <strong>red-haired</strong> person and one with a <strong>green-haired</strong> person.</li>
        </ul>
        
        <p>You wake up in one of these rooms. You look in a mirror and see you have <strong>red hair</strong>.</p>
        
        <div class="question">
            Conditioned on this fact, what is the probability that the coin landed Heads?
        </div>

        <div class="buttons">
            <button class="main-button" onclick="showExplanation('1/3')">1/3</button>
            <button class="main-button" onclick="showExplanation('1/2')">1/2</button>
        </div>

        <div id="explanationContainer">
            <h2 id="explanationTitle"></h2>
            <div id="explanationText"></div>
        </div>
    </div>

    <script>
        let engine, render, runner, ballInterval, autoTeleportInterval;
        let isAutoSpawning = false;
        let isAutoTeleporting = false;
        let teleporterState = { trials: 0, malfunctions: 0, successes: 0 };

        function cleanupSimulation() {
            if (ballInterval) clearInterval(ballInterval);
            if (autoTeleportInterval) clearInterval(autoTeleportInterval);
            if (runner) Matter.Runner.stop(runner);
            if (render) Matter.Render.stop(render);
            if (engine) {
                 Matter.Events.off(engine); 
                 Matter.Engine.clear(engine);
            }
            if (render && render.canvas) {
                 render.canvas.remove();
                 render.canvas = null;
                 render.context = null;
                 render.textures = {};
            }
            isAutoSpawning = false;
            isAutoTeleporting = false;
        }

        function showExplanation(choice) {
            cleanupSimulation();
            teleporterState = { trials: 0, malfunctions: 0, successes: 0, earnings1_3: 0 };

            const container = document.getElementById('explanationContainer');
            const title = document.getElementById('explanationTitle');
            const text = document.getElementById('explanationText');

            if (choice === '1/3') {
                title.innerHTML = "Your Answer: 1/3 (The Self-Sampling Assumption)";
                text.innerHTML = `
                    <p>You believe the probability is 1/3. This answer is derived from standard Bayesian reasoning and rests on what philosophers call the <strong>Self-Sampling Assumption (SSA)</strong>.</p>
                    <p><strong>The core metaphysical idea is that you should reason as if "you" are a random sample drawn from the set of all possible observers.</strong> Imagine your consciousness as an abstract entity that was randomly assigned to one of the people "God" created.</p>
                    <p>The math works like this:</p>
                    <ul>
                        <li>There are three possible observers who could be created: Red-in-Tails-World, Red-in-Heads-World, and Green-in-Heads-World.</li>
                        <li>The coin flip makes each world equally likely (1/2 probability each).</li>
                        <li>So, the prior probability of <em>being</em> any specific observer is:
                            <ul>
                                <li><code>P(being Red-in-Tails-World) = 1/2</code></li>
                                <li><code>P(being Red-in-Heads-World) = 1/2 (Heads) * 1/2 (Red) = 1/4</code></li>
                                <li><code>P(being Green-in-Heads-World) = 1/2 (Heads) * 1/2 (Green) = 1/4</code></li>
                            </ul>
                        </li>
                        <li>You observe that you have red hair. This eliminates the possibility of being the green-haired person. The two remaining possibilities are being the red-haired person from the Tails world or the red-haired person from the Heads world.</li>
                        <li>Since the probability of being Red-in-Tails is twice as high as being Red-in-Heads (1/2 vs 1/4), the conditional probability is:<br><code>P(Heads | Red) = P(Red-in-Heads) / [P(Red-in-Heads) + P(Red-in-Tails)] = (1/4) / (1/4 + 1/2) = 1/3</code>.</li>
                    </ul>
                    <p>Essentially, you reason that because the Heads world creates <em>another possible observer you could have been</em> (the green-haired one), your existence as a red-haired person is evidence against the Heads world.</p>
                    <div class="simulation-container">
                        <h3>Simulation of the 1/3 Result</h3>
                        <p>This simulation models the core of the Self-Sampling Assumption. Each ball represents one potential consciousness—a "soul"—being randomly assigned to a body.</p>
                        <p>The simulation follows this logic:</p>
                        <ul>
                            <li><strong>The Soul:</strong> A ball is dropped, representing one potential consciousness.</li>
                            <li><strong>God's Coin Flip:</strong> The first disc directs the ball left (Tails) or right (Heads) with 50/50 probability.</li>
                            <li>If <strong>Tails</strong>, the ball becomes red. A red-haired person is created.</li>
                            <li>If <strong>Heads</strong>, the ball continues to a second disc representing the observer-selection process. This creates a red-haired person half the time and a green-haired person the other half.</li>
                        </ul>
                        <p>Over many trials, you will see that for every <strong>one</strong> red ball produced by the 'Heads' path, about <strong>two</strong> red balls are produced by the 'Tails' path. This means that if you find yourself to be a red-haired observer (a red ball), you are twice as likely to have come from the Tails world. Therefore, the probability you are in a Heads world is 1 out of 3. Watch as <strong>P(Heads | Red)</strong> in the stats below converges toward 0.333.</p>
                        <canvas id="simulationCanvas" width="500" height="500"></canvas>
                        <div class="sim-controls">
                            <button id="spawnBtn" onclick="spawnBall()">Spawn Ball</button>
                            <button id="toggleBtn" class="off" onclick="toggleAutoSpawn()">Start Auto-Spawn</button>
                        </div>
                        <div class="stats">
                             <div class="stat-item"><span class="stat-label">Heads: Red</span><strong id="headsRedCount">0</strong></div>
                            <div class="stat-item"><span class="stat-label">Heads: Green</span><strong id="headsGreenCount">0</strong></div>
                            <div class="stat-item"><span class="stat-label">Tails: Red</span><strong id="tailsRedCount">0</strong></div>
                            <div class="stat-item"><span class="stat-label">P(Heads | Red)</span><strong id="probDisplay">N/A</strong></div>
                        </div>
                    </div>
                `;
                startPinballSimulation();
            } else if (choice === '1/2') {
                title.innerHTML = "Your Answer: 1/2 (The Self-Indication Assumption)";
                text.innerHTML = `
                    <p>You believe the probability is 1/2. This conclusion follows from what philosophers call the <strong>Self-Indication Assumption (SIA)</strong>, but it can also be reached through a more direct, intuitive logic.</p>

                    <hr style="margin: 25px 0;">

                    <h3>Explanation 1: Formal Logic (The Self-Indication Assumption)</h3>
                    <p>This is the "official" philosophical argument, which modifies Bayesian reasoning.</p>
                    <p><strong>Core Idea:</strong> Your existence itself is evidence. You are more likely to exist in a world that contains more observers. This changes your initial ("prior") beliefs about the worlds.</p>
                    <h4>Logic and Math Steps:</h4>
                    <ol>
                        <li><strong>Adjust the Prior Probabilities:</strong> The Heads world creates 2 observers, while the Tails world creates 1. SIA states that the initial probability of being in a world is proportional to its population. Therefore, your prior belief should be biased 2:1 in favor of Heads:
                            <ul>
                                <li><code>P(Heads) = 2/3</code></li>
                                <li><code>P(Tails) = 1/3</code></li>
                            </ul>
                        </li>
                        <li><strong>Apply Evidence using Bayes's Theorem:</strong> Your evidence is "I have red hair." The probability of observing this, given each world, is:
                            <ul>
                                <li><code>P(Red Hair | Heads) = 1/2</code> (since you could have been green-haired)</li>
                                <li><code>P(Red Hair | Tails) = 1</code> (since only red-haired people exist)</li>
                            </ul>
                        </li>
                        <li><strong>Calculate the Final Probability:</strong> Using the full Bayesian formula with the adjusted prior:
                            <br><code>P(Heads | Red) = [P(Red | Heads) * P(Heads)] / [P(Red | Heads)P(Heads) + P(Red | Tails)P(Tails)]</code>
                            <br><code>= [(1/2) * (2/3)] / [(1/2)(2/3) + (1)(1/3)] = (1/3) / (2/3) = <strong>1/2</strong></code></li>
                    </ol>
                    <p><strong>Conclusion:</strong> The initial bias in favor of the more populous Heads world perfectly cancels out the evidence from not being green-haired, returning the probability to exactly 1/2.</p>

                    <hr style="margin: 25px 0;">

                    <h3>Explanation 2: Intuitive Logic (The "Guaranteed Outcome")</h3>
                    <p>This is a more direct, frequentist argument that avoids complex Bayesian updates.</p>
                    <p><strong>Core Idea:</strong> A red-haired person is a <strong>guaranteed outcome</strong> of God's coin flip.</p>
                    <h4>Logic and Math Steps:</h4>
                    <ol>
                        <li><strong>Imagine the Experiment Repeated 1000 Times:</strong>
                            <ul>
                                <li>Approximately <strong>500 trials</strong> will result in Tails.</li>
                                <li>Approximately <strong>500 trials</strong> will result in Heads.</li>
                            </ul>
                        </li>
                        <li><strong>Count the Red-Haired People Created:</strong>
                            <ul>
                                <li>The 500 Tails trials create <strong>500 red-haired people</strong>.</li>
                                <li>The 500 Heads trials also create <strong>500 red-haired people</strong> (along with 500 green-haired people, who are irrelevant to your situation).</li>
                            </ul>
                        </li>
                        <li><strong>Analyze the Group You Belong To:</strong> You know you are one of the red-haired people. In total, <code>500 + 500 = 1000</code> red-haired people were created across all 1000 trials.
                        </li>
                        <li><strong>Draw the Conclusion:</strong> Out of all the red-haired people who could possibly exist, exactly half of them came from Heads worlds and half came from Tails worlds. Therefore, if you are a red-haired person, there is a 50% chance you are in a Heads world.
                        <br><code>P(Heads | Red) = (Red-Haired People from Heads Worlds) / (Total Red-Haired People) = 500 / 1000 = <strong>1/2</strong></code>
                        </li>
                    </ol>
                    <p><strong>Conclusion:</strong> This logic focuses only on the population you know you're in (the red-haired ones) and shows that this population is split evenly between the two possible outcomes of the coin flip.</p>

                    <div class="simulation-container">
                        <h3>Simulation of the 1/2 Result</h3>
                        <p>This simulation reframes the problem to highlight the "Guaranteed Outcome" logic. Imagine you are on a spaceship and use a teleporter.</p>
                        <ul>
                            <li><strong>50% chance (Tails / Success):</strong> The teleporter works perfectly. A "red-haired" you arrives at <strong>Location A</strong>.</li>
                            <li><strong>50% chance (Heads / Malfunction):</strong> The teleporter creates two copies. A "red-haired" copy of you appears at <strong>Location A</strong>, and a "green-haired" copy appears at <strong>Location B</strong>.</li>
                        </ul>
                        <p>You find yourself at <strong>Location A</strong> (you are the "red-haired" observer). What's the probability the teleporter malfunctioned?</p>
                        <p>Notice that a person appears at <strong>Location A</strong> in <em>every single trial</em>, regardless of the outcome. The existence of the observer at Location A is a guaranteed event. Because it happens in both scenarios, observing that you are at Location A provides no new information to help you decide if a malfunction occurred. Therefore, the probability of a malfunction (Heads) remains its original 50% chance. Watch as the empirical probability below converges toward 0.500.</p>
                        <div id="teleporter-viz">
                            <div class="location-container">
                                <div class="location-label">Spaceship</div>
                                <div class="location" id="spaceship"><div class="person"></div></div>
                            </div>
                            <div class="location-container">
                                <div class="location-label">Location A</div>
                                <div class="location" id="locationA"></div>
                            </div>
                             <div class="location-container">
                                <div class="location-label">Location B</div>
                                <div class="location" id="locationB"></div>
                            </div>
                        </div>
                        <div class="sim-controls">
                            <button onclick="runTeleport()">Teleport</button>
                            <button id="toggleTeleportBtn" class="off" onclick="toggleAutoTeleport()">Start Auto-Teleport</button>
                        </div>
                        <div class="stats" id="teleporter-stats">
                            <div class="stat-item"><span class="stat-label">Malfunctions (Heads)</span><strong id="malfunctions">0</strong></div>
                            <div class="stat-item"><span class="stat-label">Total Trials</span><strong id="totalTrials">0</strong></div>
                            <div class="stat-item"><span class="stat-label">Successes (Tails)</span><strong id="successes">0</strong></div>
                            <div class="stat-item"><span class="stat-label">P(Malfunction | Location A)</span><strong id="probHeadsAtA">N/A</strong></div>
                        </div>
                    </div>
                `;
                updateTeleporterStats();
            }
            container.style.display = 'block';
        }

        function spawnBall() {
            if (!engine) return;
            const width = render.options.width;
            const ballRadius = 8;
            const ball = Matter.Bodies.circle(
                width / 2 + (Math.random() - 0.5) * 2, 
                20, 
                ballRadius, 
                { restitution: 0.1, friction: 0 }
            );
            ball.customProps = { state: 'initial', color: '#111', touchingPin: false };
            Matter.World.add(engine.world, ball);
        }

        function toggleAutoSpawn() {
            isAutoSpawning = !isAutoSpawning;
            const toggleBtn = document.getElementById('toggleBtn');
            if (isAutoSpawning) {
                ballInterval = setInterval(spawnBall, 200);
                toggleBtn.textContent = 'Stop Auto-Spawn';
                toggleBtn.className = 'on';
            } else {
                clearInterval(ballInterval);
                ballInterval = null;
                toggleBtn.textContent = 'Start Auto-Spawn';
                toggleBtn.className = 'off';
            }
        }

        function startPinballSimulation() {
            const canvas = document.getElementById('simulationCanvas');
            if (!canvas) return;
            const width = canvas.width;
            const height = canvas.height;

            engine = Matter.Engine.create();
            engine.world.gravity.y = 1; 
            render = Matter.Render.create({
                canvas: canvas,
                engine: engine,
                options: { width: width, height: height, wireframes: false, background: '#fff' }
            });
            runner = Matter.Runner.create();
            
            const counts = { tailsRed: 0, headsRed: 0, headsGreen: 0 };
            const ballRadius = 8;
            const pinRadius = 60;
            const pinOptions = { isStatic: true, friction: 0, restitution: 0.1, label: 'pin' };
            
            const pin1 = Matter.Bodies.circle(width / 2, 160, pinRadius, pinOptions);
            const pin2 = Matter.Bodies.circle(width / 2 + pinRadius + ballRadius, 320, pinRadius, pinOptions);
            
            const floor = Matter.Bodies.rectangle(width / 2, height + 30, width, 60, { isStatic: true });

            Matter.World.add(engine.world, [pin1, pin2, floor]);
            
            function updateStats() {
                document.getElementById('tailsRedCount').textContent = counts.tailsRed;
                document.getElementById('headsRedCount').textContent = counts.headsRed;
                document.getElementById('headsGreenCount').textContent = counts.headsGreen;
                
                const totalRed = counts.tailsRed + counts.headsRed;
                if (totalRed > 0) {
                    const prob = counts.headsRed / totalRed;
                    document.getElementById('probDisplay').textContent = prob.toFixed(3);
                } else {
                    document.getElementById('probDisplay').textContent = 'N/A';
                }
            }
            
            Matter.Events.on(engine, 'collisionStart', function(event) {
                event.pairs.forEach(pair => {
                    let ball = null;
                    if (pair.bodyA.label === 'pin' && !pair.bodyB.isStatic) ball = pair.bodyB;
                    if (pair.bodyB.label === 'pin' && !pair.bodyA.isStatic) ball = pair.bodyA;
                    
                    if (ball && !ball.isStatic) {
                         ball.customProps.touchingPin = true;
                         if (ball.customProps.state === 'initial' && (pair.bodyA === pin1 || pair.bodyB === pin1)) {
                            Matter.Body.applyForce(ball, ball.position, { x: 0.002 * (Math.random() < 0.5 ? -1 : 1), y: -0.005 });
                            ball.customProps.state = 'on_pin1';
                         } else if (ball.customProps.state === 'falling_to_pin2' && (pair.bodyA === pin2 || pair.bodyB === pin2)) {
                             Matter.Body.applyForce(ball, ball.position, { x: 0.002 * (Math.random() < 0.5 ? -1 : 1), y: -0.005 });
                             ball.customProps.state = 'on_pin2';
                         }
                    }
                });
            });
            
            Matter.Events.on(engine, 'collisionEnd', function(event) {
                event.pairs.forEach(pair => {
                    let ball = null;
                    if (pair.bodyA.label === 'pin') ball = pair.bodyB;
                    if (pair.bodyB.label === 'pin') ball = pair.bodyA;
                    if (ball && !ball.isStatic) ball.customProps.touchingPin = false;
                });
            });

            Matter.Events.on(engine, 'afterUpdate', function() {
                const bodiesToRemove = [];
                engine.world.bodies.forEach(body => {
                    if (body.isStatic) return;

                    if (!body.customProps.touchingPin) {
                        Matter.Body.setVelocity(body, { x: 0, y: body.velocity.y });
                    }

                    if (body.customProps.state === 'on_pin1' && body.position.y > pin1.position.y) {
                        if (body.position.x < pin1.position.x) { // TAILS
                            body.customProps.label = 'T';
                            body.customProps.outcome = 'tailsRed';
                            body.customProps.color = 'crimson';
                            body.customProps.state = 'finished';
                            counts.tailsRed++;
                            updateStats();
                        } else { // HEADS
                            body.customProps.label = 'H';
                            body.customProps.state = 'falling_to_pin2';
                        }
                    }

                    if (body.customProps.state === 'on_pin2' && body.position.y > pin2.position.y) {
                        if (body.position.x < pin2.position.x) { // RED
                            body.customProps.outcome = 'headsRed';
                            body.customProps.color = 'crimson';
                            counts.headsRed++;
                        } else { // GREEN
                            body.customProps.outcome = 'headsGreen';
                            body.customProps.color = 'limegreen';
                            counts.headsGreen++;
                        }
                        body.customProps.state = 'finished';
                        updateStats();
                    }

                    if (body.position.y > height + ballRadius) {
                        bodiesToRemove.push(body);
                    }
                });

                bodiesToRemove.forEach(body => Matter.World.remove(engine.world, body));
            });
            
            Matter.Events.on(render, 'afterRender', function() {
                const context = render.context;
                context.font = '16px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                context.fillStyle = 'white';
                context.fillText('Tails | Heads', pin1.position.x, pin1.position.y);
                context.fillText('Red | Green', pin2.position.x, pin2.position.y);
                
                engine.world.bodies.forEach(body => {
                    if (body.isStatic) return;
                    if (body.customProps) {
                        body.render.fillStyle = body.customProps.color;
                        if (body.customProps.label) {
                             context.font = 'bold 10px Arial';
                             if(body.customProps.label === 'H') {
                                 context.fillStyle = 'black';
                             } else {
                                 context.fillStyle = 'white';
                             }
                             context.fillText(body.customProps.label, body.position.x, body.position.y);
                        }
                    }
                });
            });

            Matter.Runner.run(runner, engine);
            Matter.Render.run(render);
        }

        function runTeleport() {
            teleporterState.trials++;
            const spaceship = document.getElementById('spaceship');
            const locationA = document.getElementById('locationA');
            const locationB = document.getElementById('locationB');

            spaceship.innerHTML = '<div class="person"></div>';
            locationA.innerHTML = '';
            locationB.innerHTML = '';
            locationA.style.backgroundColor = '#ccc';
            locationB.style.backgroundColor = '#ccc';

            setTimeout(() => {
                spaceship.innerHTML = '';

                const malfunction = Math.random() < 0.5;

                if (malfunction) { // Heads world
                    teleporterState.malfunctions++;
                    locationA.innerHTML = '<div class="person"></div>';
                    locationB.innerHTML = '<div class="person"></div>';
                    locationA.style.backgroundColor = 'crimson';
                    locationB.style.backgroundColor = 'limegreen';
                } else { // Tails world
                    teleporterState.successes++;
                    locationA.innerHTML = '<div class="person"></div>';
                    locationA.style.backgroundColor = 'crimson';
                }

                updateTeleporterStats();
            }, 200);
        }

        function toggleAutoTeleport() {
            isAutoTeleporting = !isAutoTeleporting;
            const toggleBtn = document.getElementById('toggleTeleportBtn');
            if (isAutoTeleporting) {
                autoTeleportInterval = setInterval(runTeleport, 200);
                toggleBtn.textContent = 'Stop Auto-Teleport';
                toggleBtn.className = 'on';
            } else {
                clearInterval(autoTeleportInterval);
                autoTeleportInterval = null;
                toggleBtn.textContent = 'Start Auto-Teleport';
                toggleBtn.className = 'off';
            }
        }

        function updateTeleporterStats() {
            document.getElementById('malfunctions').textContent = teleporterState.malfunctions;
            document.getElementById('successes').textContent = teleporterState.successes;
            document.getElementById('totalTrials').textContent = teleporterState.trials;

            if (teleporterState.trials > 0) {
                const prob = teleporterState.malfunctions / teleporterState.trials;
                document.getElementById('probHeadsAtA').textContent = prob.toFixed(3);
            } else {
                document.getElementById('probHeadsAtA').textContent = 'N/A';
            }
        }
    </script>
</body>
</html>
