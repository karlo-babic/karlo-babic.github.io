<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spacetime Explorer</title>
    <style>
        :root {
            --bg-color: #050507;
            --theme-color: #00f3ff; /* Dynamic accent color */
            --glass-bg: rgba(10, 10, 15, 0.85);
            --font-mono: 'Courier New', Courier, monospace;
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --hud-width: 600px;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: white;
            font-family: var(--font-sans);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        /* Canvas Layers */
        #particle-canvas, #grid-canvas, #time-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #particle-canvas { z-index: 1; } /* Background stars */
        #grid-canvas     { z-index: 3; } /* Grid lines */
        #time-canvas     { z-index: 4; } /* Time Spiral */

        /* 
         * HUD PANELS 
         */
        .hud-panel {
            position: absolute;
            width: 90%;
            max-width: var(--hud-width);
            text-align: center;
            z-index: 100; /* Increased z-index */
            pointer-events: none;
            transition: color 0.5s ease;
            /* Chrome Fixes: */
            transform: translateZ(0); 
            contain: layout paint; /* optimization to separate it from canvas repaints */
        }

        #hud-space { top: 3vh; color: var(--theme-color); }
        #hud-time { bottom: 3vh; color: var(--theme-color); }

        .hud-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            pointer-events: auto; /* Re-enable clicks for buttons */
        }

        .hud-label {
            font-size: 0.75rem;
            opacity: 0.7;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .hud-value-primary {
            font-family: var(--font-mono);
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 15px currentColor;
            min-width: 200px;
        }

        .hud-value-secondary {
            font-size: 1rem;
            opacity: 0.8;
            margin-bottom: 5px;
            font-weight: 300;
        }

        .hud-match {
            background: var(--glass-bg);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 6px 16px;
            border-radius: 20px;
            display: inline-block;
            font-size: 0.85rem;
            margin-top: 5px;
            color: white;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
            pointer-events: auto; /* Required to capture clicks inside hud-panel */
        }
        .hud-match:hover {
            background: rgba(255,255,255,0.2);
            border-color: var(--theme-color);
        }

        /* Navigation Buttons */
        .nav-btn {
            background: transparent;
            border: 1px solid currentColor;
            color: currentColor;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            opacity: 0.6;
            transition: all 0.2s;
        }
        .nav-btn:hover { opacity: 1; background: rgba(255,255,255,0.1); transform: scale(1.1); }
        .nav-btn:active { transform: scale(0.9); }

        /* 
         * SCALE GAUGE (Left Side)
         */
        #scale-gauge {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            height: 300px;
            width: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            z-index: 10;
        }
        #gauge-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50%; /* Dynamic */
            background: var(--theme-color);
            box-shadow: 0 0 10px var(--theme-color);
            transition: height 0.1s, background 0.5s;
        }
        .gauge-marker {
            position: absolute;
            left: 10px;
            font-size: 0.7rem;
            opacity: 0.5;
            text-transform: uppercase;
        }

        /* 
         * VIEWPORT & CONTROL RING
         */
        #viewport-container {
            position: relative;
            width: 340px;
            height: 340px;
            z-index: 5;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Chrome Fix: Create strict stacking context */
            isolation: isolate;
        }

        @media (min-width: 768px) {
            #viewport-container { width: 550px; height: 550px; }
            .hud-value-primary { font-size: 2.5rem; }
        }

        /* The Control Ring (Input) */
        #control-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            cursor: grab;
            z-index: 20;
            /* Visual Tick Marks */
            background: repeating-conic-gradient(
                rgba(255, 255, 255, 0.03) 0deg, 
                rgba(255, 255, 255, 0.03) 1deg, 
                transparent 1deg, 
                transparent 10deg
            );
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #control-ring:active { cursor: grabbing; }

        /* The Handle Knob */
        #handle-knob {
            position: absolute;
            top: 50%;
            right: -10px;
            width: 20px;
            height: 40px;
            background: var(--theme-color);
            border-radius: 4px;
            transform: translateY(-50%);
            box-shadow: 0 0 15px var(--theme-color);
            pointer-events: none;
            transition: background 0.5s;
        }

        /* 
         * The Tunnel (Objects) 
         */
        #tunnel-view {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            
            /* Masking Logic */
            mask-image: radial-gradient(circle, black 70%, transparent 100%);
            -webkit-mask-image: radial-gradient(circle, black 70%, transparent 100%);
            
            z-index: 6; 
            
            /* Chrome Critical Fix: Enforce the mask on GPU layers */
            transform: translateZ(0); 
        }

        .tunnel-item {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            pointer-events: none;
            /* Chrome Fix: Removed 'will-change' to prevent memory overflow/lag */
            /* Chrome Fix: Hardware acceleration hints */
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        .item-label {
            font-size: 2rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 0 10px black;
            margin-bottom: 5px;
        }
        .item-desc {
            font-size: 0.9rem;
            color: #ccc;
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            border-radius: 4px;
        }

    </style>
</head>
<body>

    <!-- Dynamic Background Particles -->
    <canvas id="particle-canvas"></canvas>

    <!-- Left Side: Orientation Gauge -->
    <div id="scale-gauge">
        <div id="gauge-fill"></div>
        <div class="gauge-marker" style="top: 0%">Cosmic</div>
        <div class="gauge-marker" style="top: 45%">Human</div>
        <div class="gauge-marker" style="bottom: 0%">Quantum</div>
    </div>

    <!-- Top HUD: Space -->
    <div id="hud-space" class="hud-panel">
        <div class="hud-label">Diameter of View</div>
        <div class="hud-row">
            <button class="nav-btn" id="btn-prev-space">&lt;</button>
            <div class="hud-value-primary" id="val-space-sci">1.00 m</div>
            <button class="nav-btn" id="btn-next-space">&gt;</button>
        </div>
        <div class="hud-value-secondary" id="val-space-human">1 meter</div>
        <div class="hud-match" id="match-space">Object: Dog</div>
    </div>

    <!-- Center Viewport -->
    <div id="viewport-container">
        <!-- Fractal Grid (Inside Viewport) -->
        <canvas id="grid-canvas"></canvas>
        <!-- Temporal Helix Layer (Moved Inside) -->
        <canvas id="time-canvas"></canvas>
        
        <!-- Text/Object Tunnel -->
        <div id="tunnel-view"></div>
        
        <!-- Input Ring -->
        <div id="control-ring">
            <div id="handle-knob"></div>
        </div>
    </div>

    <!-- Bottom HUD: Time -->
    <div id="hud-time" class="hud-panel">
        <div class="hud-label">Light Travel Time (t = d/c)</div>
        <div class="hud-row">
            <button class="nav-btn" id="btn-prev-time">&lt;</button>
            <div class="hud-value-primary" id="val-time-sci">3.33 ns</div>
            <button class="nav-btn" id="btn-next-time">&gt;</button>
        </div>
        <div class="hud-value-secondary" id="val-time-human">3.3 nanoseconds</div>
        <div class="hud-match" id="match-time">Event: CPU Cycle</div>
    </div>

<script>
/**
 * SPACETIME EXPLORER
 * ------------------
 * Interactive scale visualizer.
 * 1 Rotation = 1 order of magnitude (x10 zoom).
 */

// ==========================================
// DATA & CONSTANTS
// ==========================================

const C = 299792458; // Speed of light (m/s)

const THEMES = {
    micro: '#008888',  // Cyan
    human: '#ffffff',  // White/Greenish
    macro: '#8800ff'   // Magenta
};

DB = {
    space: [
        // --- QUANTUM & MICROSCOPIC (Size/Diameter) ---
        { name: "Planck Length", size: 1.6e-35, desc: "Smallest theoretical size" },
        { name: "Proton Charge Diameter", size: 8.41e-16, desc: "Measured size of proton" },
        { name: "Hydrogen Atom", size: 1.0e-10, desc: "Diameter of smallest atom" },
        { name: "Transistor Gate", size: 1.0e-9, desc: "Feature size" },
        { name: "DNA Helix Width", size: 2.0e-9, desc: "Diameter of DNA strand" },
        { name: "Coronavirus", size: 1.0e-7, desc: "Diameter of virus" },
        { name: "Human Hair", size: 1.0e-5, desc: "Thickness of strand" },
        { name: "Grain of Sand", size: 5.0e-4, desc: "Diameter of coarse sand" },
        
        // --- HUMAN & GEOGRAPHIC (Size/Length) ---
        { name: "Coffee Bean", size: 0.01, desc: "Length of bean" },
        { name: "Smartphone", size: 0.15, desc: "Height of device" },
        { name: "Human Height", size: 1.7, desc: "Average adult" },
        { name: "Blue Whale", size: 30, desc: "Length of largest animal" },
        { name: "Eiffel Tower", size: 330, desc: "Height of structure" },
        { name: "Mt. Everest", size: 8849, desc: "Height above sea level" },
        { name: "Earth Diameter", size: 1.27e7, desc: "Planet width" },
        
        // --- ASTRONOMICAL (Distances vs Sizes) ---
        { name: "Dist. to Moon", size: 3.84e8, desc: "Distance from Earth to Moon" },
        { name: "Sun Diameter", size: 1.39e9, desc: "Width of the Star" },
        { name: "Dist. to Sun", size: 1.5e11, desc: "1 AU (Distance from Earth)" },
        { name: "Dist. to Voyager 1", get size() { return 2.5435e13 + (Date.now() - 1.769e12) * 17 }, desc: "Farthest human object" },
        { name: "One Light Year", size: 9.46e15, desc: "Distance light travels in 1 yr" },
        { name: "Dist. to Proxima", size: 4.02e16, desc: "Nearest Star" },
        { name: "Dist. to Galactic Center", size: 2.46e20, desc: "To the Milky Way Core" },
        { name: "Milky Way Diameter", size: 1.00e21, desc: "Width of our Galaxy" },
        { name: "Dist. to Andromeda", size: 2.40e22, desc: "Nearest Spiral Galaxy" },
        { name: "Laniakea Diameter", size: 4.73e24, desc: "Width of local Supercluster" },
        { name: "Observable Universe", size: 8.8e26, desc: "Visibility Limit" }
    ],
    time: [
        // --- SUB-ATOMIC & ULTRAFAST (Duration) ---
        { name: "Planck Time", time: 5.39e-44, desc: "Smallest theoretical duration" },
        { name: "Top Quark Lifetime", time: 5.0e-25, desc: "Shortest lived known particle" },
        { name: "Higgs Boson Life", time: 1.56e-22, desc: "Duration before decay" },
        { name: "Visible Light Cycle", time: 2.0e-15, desc: "Period of green light wave" },
        { name: "Chemical Bond Vibe", time: 1.0e-13, desc: "Period of molecular vibration" },
        { name: "Transistor Switch", time: 1.0e-11, desc: "Time to flip state" },
        { name: "CPU Cycle (3GHz)", time: 3.33e-10, desc: "Duration of one tick" },
        
        // --- HUMAN EXPERIENCE (Duration) ---
        { name: "Camera Flash", time: 0.0001, desc: "Duration of strobe" },
        { name: "Human Blink", time: 0.1, desc: "Duration" },
        { name: "Reaction Time", time: 0.25, desc: "Visual stimulus response" },
        { name: "Heartbeat Interval", time: 0.8, desc: "Time between beats" },
        { name: "One Day", time: 86400, desc: "Earth rotation duration" },
        { name: "Lunar Cycle", time: 2.55e6, desc: "Duration (29.5 days)" },
        { name: "One Year", time: 3.16e7, desc: "Earth orbit duration" },
        { name: "Human Lifespan", time: 2.5e9, desc: "Average duration" },
        
        // --- HISTORY (Time Ago) ---
        { name: "Since Gunpowder", time: 3.16e10, desc: "Invented ~1,000 years ago" },
        { name: "Since Bronze Swords", time: 1.14e11, desc: "Invented ~3,600 years ago" },
        { name: "Since Writing Began", time: 1.58e11, desc: "Invented ~5,000 years ago" },
        { name: "Since Agriculture", time: 3.79e11, desc: "Started ~12,000 years ago" },
        { name: "Since Migration from Africa", time: 1.89e12, desc: "Happened ~60,000 years ago" },
        { name: "Since Modern Humans Emerged", time: 9.47e12, desc: "Happened ~300k years ago" },
        { name: "Since Genus Homo Emerged", time: 7.89e13, desc: "Happened ~2.5m years ago" },
        
        // --- EVOLUTION & GEOLOGY (Time Ago) ---
        { name: "Since Dino Extinction", time: 2.08e15, desc: "Asteroid impact (~66m ya)" },
        { name: "Since First Mammals", time: 6.31e15, desc: "Triassic (~200m ya)" },
        { name: "Since First Reptiles", time: 9.46e15, desc: "Carboniferous (~300m ya)" },
        { name: "Since First Insects", time: 1.26e16, desc: "Devonian (~400m ya)" },
        { name: "Since Land Plants", time: 1.50e16, desc: "Ordovician (~475m ya)" },
        { name: "Since First Fish", time: 1.58e16, desc: "Cambrian (~500m ya)" },
        { name: "Since Multicellular Life", time: 3.15e16, desc: "Life evolved (~1b ya)" },
        { name: "Since Sex. Repro.", time: 3.79e16, desc: "Eukaryotes (~1.2b ya)" },
        { name: "Since Photosynthesis", time: 1.07e17, desc: "Cyanobacteria (~3.4b ya)" },
        { name: "Since Life Began", time: 1.14e17, desc: "Simple cells (~3.6b ya)" },
        
        // --- COSMIC SCALE (Time Ago) ---
        { name: "Age of Earth", time: 1.43e17, desc: "Formed ~4.5b years ago" },
        { name: "Age of Universe", time: 4.35e17, desc: "Big Bang ~13.8b years ago" }
    ]
};

// ==========================================
// APP STATE
// ==========================================

const state = {
    rotation: 0,        // In radians. 2PI = 1 order of magnitude (x10)
    velocity: 0,        // Momentum
    isDragging: false,
    lastAngle: 0,
    targetRotation: null, // For auto-pilot
    currentDiameter: 1
};

// ==========================================
// UTILITIES & FORMATTERS
// ==========================================

function formatDistance(m) {
    if (m < 1e-9) return (m * 1e12).toFixed(1) + " pm";
    if (m < 1e-6) return (m * 1e9).toFixed(1) + " nm";
    if (m < 1e-3) return (m * 1e6).toFixed(1) + " μm";
    if (m < 1)    return (m * 1e3).toFixed(1) + " mm";
    if (m < 1000) return m.toFixed(1) + " m";
    if (m < 1e6)  return (m / 1000).toFixed(1) + " km";

    // Millions of km (e.g. Sun Diameter) up to 1 AU
    if (m < 1.496e11) {
        let km = m / 1000;
        if (km >= 1e6) return (km / 1e6).toFixed(2) + " million km";
        return km.toLocaleString() + " km";
    }
    
    // Astronomical Units (up to 1 Light Year)
    if (m < 9.461e15) return (m / 1.496e11).toFixed(2) + " AU";
    
    // Light Years (with word scaling)
    let ly = m / 9.461e15;
    if (ly >= 1e12) return (ly / 1e12).toFixed(2) + " trillion ly";
    if (ly >= 1e9)  return (ly / 1e9).toFixed(2) + " billion ly";
    if (ly >= 1e6)  return (ly / 1e6).toFixed(2) + " million ly";
    return ly.toLocaleString(undefined, { maximumFractionDigits: 2 }) + " ly";
}

function formatTime(s) {
    if (s < 1e-18) return (s * 1e21).toFixed(1) + " zs";
    if (s < 1e-15) return (s * 1e18).toFixed(1) + " as";
    if (s < 1e-12) return (s * 1e15).toFixed(1) + " fs";
    if (s < 1e-9)  return (s * 1e12).toFixed(1) + " ps";
    if (s < 1e-6)  return (s * 1e9).toFixed(1) + " ns";
    if (s < 1e-3)  return (s * 1e6).toFixed(1) + " μs";
    if (s < 1)     return (s * 1e3).toFixed(1) + " ms";
    if (s < 60)    return s.toFixed(2) + " s";
    if (s < 3600)  return (s/60).toFixed(1) + " min";
    if (s < 86400) return (s/3600).toFixed(1) + " hrs";
    if (s < 3.15e7) return (s/86400).toFixed(1) + " days";

    // Years (with word scaling)
    // Using 31,557,600 seconds per year (Julian year)
    let yrs = s / 3.15576e7;
    if (yrs >= 1e12) return (yrs / 1e12).toFixed(2) + " trillion yrs";
    if (yrs >= 1e9)  return (yrs / 1e9).toFixed(2) + " billion yrs";
    if (yrs >= 1e6)  return (yrs / 1e6).toFixed(2) + " million yrs";
    if (yrs >= 1000) return yrs.toLocaleString(undefined, { maximumFractionDigits: 0 }) + " yrs";
    return yrs.toFixed(1) + " yrs";
}

function getClosest(val, arr, key) {
    let best = arr[0];
    let minDiff = Math.abs(Math.log10(val) - Math.log10(best[key]));
    arr.forEach(item => {
        let diff = Math.abs(Math.log10(val) - Math.log10(item[key]));
        if (diff < minDiff) { minDiff = diff; best = item; }
    });
    return best;
}

// ==========================================
// GRAPHICS ENGINE (GRID, PARTICLES, TIME SPIRAL)
// ==========================================

class FractalGrid {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        // Match container size
        const box = document.getElementById('viewport-container').getBoundingClientRect();
        this.canvas.width = box.width;
        this.canvas.height = box.height;
        this.cx = box.width / 2;
        this.cy = box.height / 2;
    }

    render(zoomLevel) {
        // zoomLevel = log10(diameter).
        // If zoomLevel increases, we are zooming OUT.
        // Grid lines should move INWARDS (collapse).
        
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--theme-color');
        this.ctx.lineWidth = 1;

        // Create concentric circles
        // We need a looping offset based on the decimal part of zoomLevel
        const offset = zoomLevel % 1; 
        
        // Draw 5 main rings
        for (let i = 0; i < 6; i++) {
            // As zoomLevel goes UP (zoom out), radius should shrink.
            // So radius is related to (1 - offset).
            let rFactor = (i + 1 - offset);
            
            // Logarithmic spacing feels more natural for zoom
            // Map 0..5 range to pixels 0..width
            let radius = Math.pow(rFactor, 2.5) * (this.cx / 20); 

            if (radius > this.cx) continue;

            let alpha = 1;
            // Fade out near center
            if (radius < 20) alpha = radius / 20;
            // Fade out near edge
            if (radius > this.cx * 0.8) alpha = 1 - ((radius - this.cx*0.8) / (this.cx*0.2));

            this.ctx.globalAlpha = alpha * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(this.cx, this.cy, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        // Draw crosshairs
        this.ctx.globalAlpha = 0.1;
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.cy); this.ctx.lineTo(this.canvas.width, this.cy);
        this.ctx.moveTo(this.cx, 0); this.ctx.lineTo(this.cx, this.canvas.height);
        this.ctx.stroke();
    }
}

class ParticleSystem {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.particles = [];
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Ensure particles are pushed to the array
        for(let i=0; i<100; i++) {
            this.particles.push(this.resetParticle({}, true));
        }
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.cx = this.canvas.width / 2;
        this.cy = this.canvas.height / 2;
    }

    randomizeXY(p) {
        // Use polar coordinates to create a circular tunnel instead of a square box
        const spread = Math.max(this.canvas.width, this.canvas.height) * 2;
        const angle = Math.random() * Math.PI * 2;
        // Sqrt ensures uniform distribution across the circle's area
        const radius = Math.sqrt(Math.random()) * (spread / 2);
        p.x = Math.cos(angle) * radius;
        p.y = Math.sin(angle) * radius;
    }

    resetParticle(p, initial = false) {
        this.randomizeXY(p);
        
        // Depth (Z): 0.1 = Very close, 5.0 = Far away
        if (initial) {
            p.z = Math.random() * 5.0 + 0.1;
        } else {
            p.z = 5.0; 
        }
        
        p.size = Math.random() * 2 + 1.5; 
        return p;
    }

    render(velocity) {
        // Optimization: Full clear is faster than fade effects (destination-out)
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.fillStyle = '#ffffff';

        // Apply velocity scaling
        let dz = velocity * 0.5;

        this.particles.forEach(p => {
            p.z += dz;

            // Recycling:
            // Add random jitter to Z when resetting to prevent "sheets" of particles
            
            // If moved too far back (Z > 5), reset to front
            if (p.z > 5.0) {
                p.z = 0.1 + Math.random() * 0.5;
                this.randomizeXY(p);
            }
            // If moved past camera (Z < 0.1), reset to back
            if (p.z < 0.1) {
                p.z = 5.0 - Math.random() * 0.5;
                this.randomizeXY(p);
            }

            // 3D Projection
            const scale = 1 / p.z;
            const screenX = this.cx + p.x * scale;
            const screenY = this.cy + p.y * scale;
            const currentSize = p.size * scale;

            // Render if on screen
            if (screenX > 0 && screenX < this.canvas.width && screenY > 0 && screenY < this.canvas.height) {
                // Opacity based on depth
                const alpha = Math.min(1, (5.0 - p.z) / 2.0);
                this.ctx.globalAlpha = alpha;
                
                this.ctx.beginPath();
                this.ctx.arc(screenX, screenY, currentSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
        
        this.ctx.globalAlpha = 1.0;
    }
}

class TimeSpiral {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        
        // Dynamic Logarithmic Bounds based on DB data
        // Assumes DB.time is sorted ascending
        const firstEvent = DB.time[0].time;
        const lastEvent = DB.time[DB.time.length - 1].time;

        this.minLog = Math.log10(firstEvent); 
        this.maxLog = Math.log10(lastEvent);
        
        // Spiral Tightness: 
        // Calculate number of orders of magnitude
        const orders = this.maxLog - this.minLog; 
        // 1 full rotation every ~20 orders of magnitude for readability
        this.totalAngle = Math.PI * 2 * (orders / 20); 
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        // Match container size (viewport-container)
        const box = document.getElementById('viewport-container').getBoundingClientRect();
        this.canvas.width = box.width;
        this.canvas.height = box.height;
        this.cx = box.width / 2;
        this.cy = box.height / 2;
        
        // Spiral Radius Constraints (Fit inside the viewport circle)
        const maxRadius = this.cx;
        
        // Start at center (Planck Time)
        this.innerRadius = 0; 
        // End at the edge (Last Event)
        this.outerRadius = maxRadius * 0.999; 
    }

    /**
     * Maps a time value (seconds) to x,y coordinates on the spiral.
     */
    getSpiralPos(seconds) {
        let logVal = Math.log10(seconds);
        
        // Clamp values strictly to the timeline events
        if(logVal < this.minLog) logVal = this.minLog;
        if(logVal > this.maxLog) logVal = this.maxLog;

        // Normalized position (0.0 to 1.0) along the track
        const t = (logVal - this.minLog) / (this.maxLog - this.minLog);
        
        // Calculate Angle and Radius
        // Start angle offset by -PI/2 so the spiral starts at the top
        const theta = t * this.totalAngle - (Math.PI / 2); 
        const r = this.innerRadius + t * (this.outerRadius - this.innerRadius);
        
        return {
            x: this.cx + Math.cos(theta) * r,
            y: this.cy + Math.sin(theta) * r,
            t: t // Return normalized progress for gradient logic
        };
    }

    render(currentDiameter) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Convert current spatial diameter to light-travel time
        const currentTime = currentDiameter / 299792458; 

        // 1. Draw the Base Spiral Track
        this.ctx.beginPath();
        
        // Draw enough steps to cover the spiral smoothly
        const steps = 500;
        
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            // Interpolate log value between min (Planck) and max (End)
            const logVal = this.minLog + t * (this.maxLog - this.minLog);
            const pos = this.getSpiralPos(Math.pow(10, logVal));
            
            if (i === 0) this.ctx.moveTo(pos.x, pos.y);
            else this.ctx.lineTo(pos.x, pos.y);
        }
        
        // Gradient Stroke (Cyan -> White -> Magenta)
        const grad = this.ctx.createLinearGradient(
            0, 0, this.canvas.width, this.canvas.height
        );
        grad.addColorStop(0, '#00f3ff'); 
        grad.addColorStop(0.5, '#ffffff');
        grad.addColorStop(1, '#ff00ff'); 
        
        this.ctx.strokeStyle = grad;
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.3; 
        this.ctx.stroke();

        // 2. Draw Event Nodes (DB.time)
        this.ctx.globalAlpha = 1.0;
        const headPos = this.getSpiralPos(currentTime);

        DB.time.forEach(event => {
            const pos = this.getSpiralPos(event.time);
            
            // Check proximity between Current Time Cursor and this Event Node
            const dist = Math.hypot(pos.x - headPos.x, pos.y - headPos.y);
            const isActive = dist < 15; // Tighter threshold for internal view

            this.ctx.beginPath();
            if (isActive) {
                // Active Event Styling
                this.ctx.fillStyle = '#ffffff';
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = '#ffffff';
                this.ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;

                // Connector Line (Visual link to center)
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(this.cx, this.cy); 
                this.ctx.lineTo(pos.x, pos.y);    
                this.ctx.stroke();

            } else {
                // Inactive Node Styling (Subtler inside view)
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                this.ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });

        // 3. Draw the "Time Head" Cursor
        const currentLog = Math.log10(currentTime);
        if (currentLog >= this.minLog && currentLog <= this.maxLog) {
            
            // A. TETHER LINE: Connects center to the point
            this.ctx.beginPath();
            this.ctx.moveTo(this.cx, this.cy);
            this.ctx.lineTo(headPos.x, headPos.y);
            this.ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--theme-color');
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([2, 4]); // Dotted line
            this.ctx.globalAlpha = 0.5;
            this.ctx.stroke();
            this.ctx.setLineDash([]); // Reset
            this.ctx.globalAlpha = 1.0;

            // B. PULSING ANIMATION LOGIC
            // Use Date.now() for smooth independent animation
            const time = Date.now() * 0.005; 
            const pulse = Math.sin(time) * 3; // Oscillates between -3 and 3

            // C. OUTER GLOW RING (Target Reticle)
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#ffffff';
            this.ctx.lineWidth = 2;
            this.ctx.arc(headPos.x, headPos.y, 10 + pulse, 0, Math.PI * 2);
            this.ctx.stroke();

            // D. SOLID CORE DOT
            this.ctx.beginPath();
            this.ctx.fillStyle = '#ffffff'; // Pure white core for max contrast
            this.ctx.shadowBlur = 20;       // Heavy glow
            this.ctx.shadowColor = getComputedStyle(document.body).getPropertyValue('--theme-color');
            this.ctx.arc(headPos.x, headPos.y, 5, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Reset Shadow
            this.ctx.shadowBlur = 0;
        }
    }
}

// ==========================================
// DOM & INTERACTION LOGIC
// ==========================================

const els = {
    ring: document.getElementById('control-ring'),
    handle: document.getElementById('handle-knob'),
    tunnel: document.getElementById('tunnel-view'),
    gaugeFill: document.getElementById('gauge-fill'),
    // Space HUD
    spaceSci: document.getElementById('val-space-sci'),
    spaceHuman: document.getElementById('val-space-human'),
    spaceMatch: document.getElementById('match-space'),
    // Time HUD
    timeSci: document.getElementById('val-time-sci'),
    timeHuman: document.getElementById('val-time-human'),
    timeMatch: document.getElementById('match-time')
};

// Initialize Graphics
const grid = new FractalGrid('grid-canvas');
const particles = new ParticleSystem('particle-canvas');
const timeSpiral = new TimeSpiral('time-canvas');

// Populate DOM Tunnel
DB.space.forEach(obj => {
    const el = document.createElement('div');
    el.className = 'tunnel-item';
    el.innerHTML = `<div class="item-label">${obj.name}</div><div class="item-desc">${obj.desc}</div>`;
    el.dataset.size = obj.size;
    els.tunnel.appendChild(el);
    obj.element = el;
});

// Navigation Functions (Auto-Pilot)
function jumpTo(targetDiameter) {
    if (!targetDiameter) return;
    // diameter = 10 ^ (radians / 2PI)
    // So: radians = log10(diameter) * 2PI
    const targetRad = Math.log10(targetDiameter) * (Math.PI * 2);
    state.targetRotation = targetRad;
}

function findNextSpace(dir) {
    // dir: 1 for next (larger), -1 for prev (smaller)
    const current = state.currentDiameter;
    // Find index of closest object
    let idx = -1;
    let minDiff = Infinity;
    DB.space.forEach((obj, i) => {
        let diff = Math.abs(Math.log10(obj.size) - Math.log10(current));
        if (diff < minDiff) { minDiff = diff; idx = i; }
    });

    // If we are very close to idx, move to idx + dir
    // If we are far, move to idx (snap) or idx + dir based on direction
    const exactMatch = minDiff < 0.1;
    let targetIdx = exactMatch ? idx + dir : (dir > 0 ? idx + 1 : idx - 1);
    
    // Bounds check
    if (targetIdx < 0) targetIdx = 0;
    if (targetIdx >= DB.space.length) targetIdx = DB.space.length - 1;
    
    jumpTo(DB.space[targetIdx].size);
}

function findNextTime(dir) {
    const currentLightTime = state.currentDiameter / C;
    let idx = -1;
    let minDiff = Infinity;
    DB.time.forEach((obj, i) => {
        let diff = Math.abs(Math.log10(obj.time) - Math.log10(currentLightTime));
        if (diff < minDiff) { minDiff = diff; idx = i; }
    });
    
    const exactMatch = minDiff < 0.1;
    let targetIdx = exactMatch ? idx + dir : (dir > 0 ? idx + 1 : idx - 1);

    if (targetIdx < 0) targetIdx = 0;
    if (targetIdx >= DB.time.length) targetIdx = DB.time.length - 1;
    
    // Convert time back to diameter -> d = t * c
    jumpTo(DB.time[targetIdx].time * C);
}

// Bind Buttons
document.getElementById('btn-prev-space').onclick = () => findNextSpace(-1);
document.getElementById('btn-next-space').onclick = () => findNextSpace(1);
document.getElementById('btn-prev-time').onclick = () => findNextTime(-1);
document.getElementById('btn-next-time').onclick = () => findNextTime(1);

document.getElementById('match-space').onclick = function() {
    const size = parseFloat(this.dataset.targetSize);
    if (!isNaN(size)) jumpTo(size);
};

document.getElementById('match-time').onclick = function() {
    const time = parseFloat(this.dataset.targetTime);
    if (!isNaN(time)) jumpTo(time * C); // Convert time to light-distance
};


// Input Handling
function getAngle(x, y, center) {
    return Math.atan2(y - center.y, x - center.x);
}

function handleStart(e) {
    state.isDragging = true;
    state.targetRotation = null; // Cancel auto-pilot
    state.velocity = 0;
    const rect = els.ring.getBoundingClientRect();
    const center = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    state.lastAngle = getAngle(cx, cy, center);
}

function handleMove(e) {
    if (!state.isDragging) return;
    e.preventDefault();
    const rect = els.ring.getBoundingClientRect();
    const center = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    
    const angle = getAngle(cx, cy, center);
    let delta = angle - state.lastAngle;
    
    // Normalize wrap-around
    if (delta > Math.PI) delta -= Math.PI * 2;
    if (delta < -Math.PI) delta += Math.PI * 2;
    
    state.rotation += delta;
    state.velocity = delta;
    state.lastAngle = angle;
}

function handleEnd() {
    state.isDragging = false;
}

els.ring.addEventListener('mousedown', handleStart);
window.addEventListener('mousemove', handleMove);
window.addEventListener('mouseup', handleEnd);
els.ring.addEventListener('touchstart', handleStart, {passive: false});
window.addEventListener('touchmove', handleMove, {passive: false});
window.addEventListener('touchend', handleEnd);
// Scroll Wheel Zoom
window.addEventListener('wheel', (e) => {
    e.preventDefault();
    // Normalize delta for smooth scaling
    const delta = e.deltaY * 0.002;
    state.velocity += delta;
    state.targetRotation = null; // Cancel auto-pilot
}, { passive: false });

// ==========================================
// MAIN LOOP
// ==========================================

function loop() {
    // 1. Physics & Auto-Pilot
    if (state.targetRotation !== null) {
        // Tweening to target
        const diff = state.targetRotation - state.rotation;
        state.rotation += diff * 0.1; // Ease factor
        state.velocity = diff * 0.1; // Sync visual speed
        if (Math.abs(diff) < 0.001) state.targetRotation = null;
    } else if (!state.isDragging) {
        // Momentum
        state.rotation += state.velocity;
        state.velocity *= 0.97; // Friction
        if (Math.abs(state.velocity) < 0.0001) state.velocity = 0;
    }

    // CLAMPING: Constrain Zoom to Data Limits
    // Min: Allow zoom down to Planck Length (1.6e-35 m)
    const minRot = Math.log10(1e-35) * (Math.PI * 2);
    // Max: Allow zoom up to Deep Future / Largest structures (8.8e26 m)
    const maxRot = Math.log10(8.8e26) * (Math.PI * 2);

    if (state.rotation < minRot) {
        state.rotation = minRot;
        state.velocity = 0;
    } else if (state.rotation > maxRot) {
        state.rotation = maxRot;
        state.velocity = 0;
    }

    // 2. Math: 1 Rotation (2PI) = 1 Order of Magnitude (Base 10)
    // Formula: Diameter = 10 ^ (Rotation / 2PI)
    const turns = state.rotation / (Math.PI * 2);
    state.currentDiameter = Math.pow(10, turns);
    const lightTime = state.currentDiameter / C;

    // 3. Update Visuals (Handle)
    els.ring.style.transform = `rotate(${state.rotation}rad)`;

    // 4. Update HUD Text
    els.spaceSci.innerText = state.currentDiameter.toExponential(2) + " m";
    els.spaceHuman.innerText = formatDistance(state.currentDiameter);
    
    const sMatch = getClosest(state.currentDiameter, DB.space, 'size');
    // Show value and store for click event
    els.spaceMatch.innerText = `Object: ${sMatch.name} (${formatDistance(sMatch.size)})`;
    els.spaceMatch.dataset.targetSize = sMatch.size;

    els.timeSci.innerText = lightTime.toExponential(2) + " s";
    els.timeHuman.innerText = formatTime(lightTime);
    
    const tMatch = getClosest(lightTime, DB.time, 'time');
    // Show value and store for click event
    els.timeMatch.innerText = `Event: ${tMatch.name} (${formatTime(tMatch.time)})`;
    els.timeMatch.dataset.targetTime = tMatch.time;

    // 5. Theme & Gauge Logic
    let theme = THEMES.human;
    let pct = 0;

    // Scale Logic: 
    // -36 (Planck Scale) to +31 (Deep Cosmic). Total range ~67 orders.
    // Map log10(dia) to 0-100%
    const logVal = Math.log10(state.currentDiameter);
    const minLog = -36; 
    const maxLog = 31;
    pct = ((logVal - minLog) / (maxLog - minLog)) * 100;
    if (pct < 0) pct = 0; if (pct > 100) pct = 100;
    
    // Color Grading
    if (state.currentDiameter < 1e-6) theme = THEMES.micro;
    else if (state.currentDiameter > 1e14) theme = THEMES.macro;
    else theme = THEMES.human;

    // Apply Theme
    document.documentElement.style.setProperty('--theme-color', theme);
    els.gaugeFill.style.height = pct + "%";

    // 6. Tunnel Rendering (Infinite Zoom)
    DB.space.forEach(obj => {
        const ratio = obj.size / state.currentDiameter;
        
        if (ratio > 0.05 && ratio < 50) {
            obj.element.style.display = 'flex';
            
            // Transform
            // Using translate3d(0,0,0) ensures GPU layer promotion
            obj.element.style.transform = `translate3d(0,0,0) scale(${ratio})`;
            
            // Opacity Logic
            let op = 1;
            // Fade in from deep zoom (ratio < 0.2)
            if (ratio < 0.3) op = (ratio - 0.05) * 3.6; 
            // Fade out to camera (ratio > 5)
            else if (ratio > 0.5) op = (5 - ratio) / 5;
            
            // Clamp Opacity
            if (op < 0) op = 0; 
            if (op > 1) op = 1;
            
            obj.element.style.opacity = op;
            obj.element.style.filter = 'none';
            
        } else {
            // Aggressively hide elements outside the sweet spot
            obj.element.style.display = 'none';
        }
    });

    // 7. Canvas Rendering
    // Pass the log10 value to grid for fractal expansion
    grid.render(logVal);
    // Render the Time Spiral
    timeSpiral.render(state.currentDiameter);
    // Pass velocity to particles for warp effect
    particles.render(state.velocity);

    requestAnimationFrame(loop);
}

// Start
// Init at 1 meter (Dog)
state.rotation = Math.log10(1.0) * (Math.PI * 2); 
loop();

</script>
</body>

</html>

